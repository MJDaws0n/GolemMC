// ---------------------------------------------------------------------------
// play.nov - handles the MC play state packets
//
// once a player is through login + config, they enter the play state
// this is where we send em the world data, spawn em in, and handle
// all the gameplay packets like movement, chat, block breaks/places etc
//
// chunks are now generated from the chunk storage system which tracks
// block modifications on top of the default flat world template
// ---------------------------------------------------------------------------

module play;

import ../../lib/standard_lib;
import ../../lib/standard_lib_macos_silicon;
import ../../lib/net;
import ../chunk;
import ../world/terrain;
import packet;
import writer;

// ---------------------------------------------------------------------------
// send the Login (Play) packet - 0x30
// this is the first packet in the play state, tells the client about
// the world theyre joining
// ---------------------------------------------------------------------------

fn send_login_play(fd: i32, entity_id: i32) -> void {
    // Login (Play) packet fields for 1.21.11:
    // - Entity ID: i32
    // - Is Hardcore: bool
    // - Dimension Count: VarInt (1)
    // - Dimension Names: array of Identifier
    // - Max Players: VarInt (ignored by client)
    // - View Distance: VarInt
    // - Simulation Distance: VarInt
    // - Reduced Debug Info: bool
    // - Enable Respawn Screen: bool
    // - Do Limited Crafting: bool
    // - Dimension Type: VarInt (registry id)
    // - Dimension Name: Identifier
    // - Hashed Seed: i64
    // - Game Mode: u8
    // - Previous Game Mode: i8 (-1 = none)
    // - Is Debug: bool
    // - Is Flat: bool
    // - Has Death Location: bool
    // - Portal Cooldown: VarInt
    // - Sea Level: VarInt
    // - Enforces Secure Chat: bool

    // we need to calculate the total size first
    let dim_name: str = "minecraft:overworld";
    let dim_name_size: i32 = varint_size(len(dim_name)) + len(dim_name);

    // calculate payload size
    let payload: i32 = 0;
    payload = payload + 4;              // entity id (i32)
    payload = payload + 1;              // is hardcore (bool)
    payload = payload + varint_size(1); // dimension count
    payload = payload + dim_name_size;  // dimension name array (1 entry)
    payload = payload + varint_size(20); // max players
    payload = payload + varint_size(10); // view distance
    payload = payload + varint_size(10); // simulation distance
    payload = payload + 1;              // reduced debug info
    payload = payload + 1;              // enable respawn screen
    payload = payload + 1;              // do limited crafting
    payload = payload + varint_size(0); // dimension type (registry id 0)
    payload = payload + dim_name_size;  // dimension name
    payload = payload + 8;              // hashed seed (i64)
    payload = payload + 1;              // game mode
    payload = payload + 1;              // previous game mode
    payload = payload + 1;              // is debug
    payload = payload + 1;              // is flat
    payload = payload + 1;              // has death location
    payload = payload + varint_size(0); // portal cooldown
    payload = payload + varint_size(63); // sea level
    payload = payload + 1;              // enforces secure chat

    let pkt_id: i32 = 48;  // 0x30 Login (Play)
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload;

    // write the packet
    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);

    write_i32(fd, entity_id);       // entity id
    write_bool(fd, false);          // not hardcore
    write_varint_to_fd(fd, 1);      // 1 dimension
    write_mc_string(fd, dim_name);  // dimension name
    write_varint_to_fd(fd, 20);     // max players (ignored)
    write_varint_to_fd(fd, 10);     // view distance
    write_varint_to_fd(fd, 10);     // simulation distance
    write_bool(fd, false);          // reduced debug info
    write_bool(fd, true);           // enable respawn screen
    write_bool(fd, false);          // do limited crafting
    write_varint_to_fd(fd, 0);      // dimension type (id 0 = first registered)
    write_mc_string(fd, dim_name);  // dimension name
    write_i64_zero(fd);             // hashed seed
    write_byte(fd, 1);              // game mode (1 = creative)
    write_byte(fd, 255);            // previous game mode (-1 as unsigned byte)
    write_bool(fd, false);          // is debug world
    write_bool(fd, true);           // is flat world
    write_bool(fd, false);          // has death location
    write_varint_to_fd(fd, 0);      // portal cooldown
    write_varint_to_fd(fd, 63);     // sea level
    write_bool(fd, false);          // enforces secure chat
}

// ---------------------------------------------------------------------------
// send Game Event packet - 0x26
// used to tell the client various things like start waiting for chunks
// ---------------------------------------------------------------------------

fn send_game_event(fd: i32, event: i32, value: i32) -> void {
    // Game Event: u8 event + f32 value
    let payload: i32 = 1 + 4;  // byte + float
    let pkt_id: i32 = 38;  // 0x26 Game Event
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload;

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_byte(fd, event);
    write_i32(fd, value);  // float as raw bits
}

// ---------------------------------------------------------------------------
// send Set Default Spawn Position - 0x5F
// tells the client where the world spawn is
// in 1.21.11 this now includes dimension name + yaw + pitch
// ---------------------------------------------------------------------------

fn send_spawn_position(fd: i32, x: i32, y: i32, z: i32) -> void {
    // Dimension Name (Identifier) + Position (packed i64) + Yaw (float) + Pitch (float)
    let dim_name: str = "minecraft:overworld";
    let dim_name_size: i32 = varint_size(len(dim_name)) + len(dim_name);
    let payload: i32 = dim_name_size + 8 + 4 + 4;  // identifier + position + yaw + pitch
    let pkt_id: i32 = 95;  // 0x5F Set Default Spawn Position
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload;

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_mc_string(fd, dim_name);  // dimension name
    write_position(fd, x, y, z);
    write_float_zero(fd);  // yaw = 0.0
    write_float_zero(fd);  // pitch = 0.0
}

// ---------------------------------------------------------------------------
// send Synchronize Player Position - 0x46
// teleports the player to a specific position
// the client wont render anything until it gets this
// ---------------------------------------------------------------------------

fn send_player_position(fd: i32, x: i32, y: i32, z: i32, teleport_id: i32) -> void {
    // Teleport ID: VarInt
    // X: Double
    // Y: Double
    // Z: Double
    // Vel X: Double (0.0)
    // Vel Y: Double (0.0)
    // Vel Z: Double (0.0)
    // Yaw: Float
    // Pitch: Float
    // Flags: Int (0 = all absolute)

    let payload: i32 = 0;
    payload = payload + varint_size(teleport_id);  // teleport id
    payload = payload + 8;   // x double
    payload = payload + 8;   // y double
    payload = payload + 8;   // z double
    payload = payload + 8;   // vel x
    payload = payload + 8;   // vel y
    payload = payload + 8;   // vel z
    payload = payload + 4;   // yaw float
    payload = payload + 4;   // pitch float
    payload = payload + 4;   // flags int

    let pkt_id: i32 = 70;  // 0x46
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload;

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_varint_to_fd(fd, teleport_id);
    write_double_from_i32(fd, x);   // x
    write_double_from_i32(fd, y);   // y (spawn on top of the flat world)
    write_double_from_i32(fd, z);   // z
    write_double_zero(fd);          // vel x
    write_double_zero(fd);          // vel y
    write_double_zero(fd);          // vel z
    write_float_zero(fd);           // yaw
    write_float_zero(fd);           // pitch
    write_i32(fd, 0);               // flags (all absolute)
}

// ---------------------------------------------------------------------------
// send Set Center Chunk - 0x5C
// tells the client which chunk is the center for loading
// ---------------------------------------------------------------------------

fn send_center_chunk(fd: i32, chunk_x: i32, chunk_z: i32) -> void {
    let payload: i32 = varint_size(chunk_x) + varint_size(chunk_z);
    let pkt_id: i32 = 92;  // 0x5C Set Center Chunk
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload;

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_varint_to_fd(fd, chunk_x);
    write_varint_to_fd(fd, chunk_z);
}

// ---------------------------------------------------------------------------
// send a chunk data packet for a flat world
// this is one of the most complex packets - it contains the actual
// block data for a 16x384x16 column of blocks
//
// for our flat world:
// y -64 to -5 (sections -4 to -1): stone (block state 1)
// y -4 to -2 (top of section -1): dirt (block state 10)
// y -1: grass_block (block state 8)
// y 0 and above: air (block state 0)
//
// WAIT actually lets do the simple flat world:
// y -64 to -1: stone
// y 0 to 2: dirt
// y 3: grass_block
// y 4+: air
//
// nah lets keep it really simple for now - all stone below y=0,
// grass at y=0, air above. a 1-layer grass world
// ---------------------------------------------------------------------------

fn send_chunk_data(fd: i32, chunk_x: i32, chunk_z: i32, cs: str, wb: str) -> void {
    // Chunk Data and Update Light packet (0x2C in protocol 774)
    //
    // builds chunk section data from the chunk storage system
    // terrain gen is expensive so we cache each section's blocks
    // in a temp buffer to avoid scanning multiple times
    //
    // for 1.21.5+: single-value palette sections dont send data arrays
    // mixed sections use indirect palette with packed data

    // === USE PRE-ALLOCATED WORK BUFFER to avoid novus memory corruption ===
    // partition: [0..131071] = section_buf, [131072..139263] = block_cache, [139264..139775] = palette
    let section_buf: str = wb;
    let pos: i32 = 0;

    // block cache offset in the work buffer: 131072
    let cache_off: i32 = 131072;
    // palette offset in the work buffer: 139264
    let pal_off: i32 = 139264;

    // 24 sections for overworld (y -64 to 319)
    let section: i32 = 0;
    while (section < 24) {
        let base_y: i32 = (section - 4) * 16;

        // === SINGLE PASS: fill block cache, build palette, count non-air ===
        let pal_count: i32 = 0;
        let non_air: i32 = 0;

        // shortcut for sections way above terrain (all air)
        let is_high_air: bool = false;
        if (base_y >= 200) {
            // check no modifications in this section
            let count: i32 = cs_count(cs);
            let has_mods_h: bool = false;
            let ih: i32 = 0;
            while (ih < count) {
                let off: i32 = 16 + ih * 16;
                let mx: i32 = buf_read_i32(cs, off);
                let my: i32 = buf_read_i32(cs, off + 4);
                let mz: i32 = buf_read_i32(cs, off + 8);
                let cx: i32 = mx >> 4;
                let cz: i32 = mz >> 4;
                if (mx < 0 && (mx & 15) != 0) { cx = cx - 1; }
                if (mz < 0 && (mz & 15) != 0) { cz = cz - 1; }
                if (cx == chunk_x && cz == chunk_z && my >= base_y && my < base_y + 16) {
                    has_mods_h = true;
                }
                ih = ih + 1;
            }
            if (!has_mods_h) { is_high_air = true; }
        }

        if (is_high_air) {
            // all air - single value palette
            section_buf[pos] = 0;
            pos = pos + 1;
            section_buf[pos] = 0;
            pos = pos + 1;
            section_buf[pos] = 0;
            pos = pos + 1;
            section_buf[pos] = 0;
            pos = pos + 1;
            // biomes
            section_buf[pos] = 0;
            pos = pos + 1;
            section_buf[pos] = 0;
            pos = pos + 1;
        } else {
            // fill block cache for this section
            let lx: i32 = 0;
            while (lx < 16) {
                let ly: i32 = 0;
                while (ly < 16) {
                    let lz: i32 = 0;
                    while (lz < 16) {
                        let bid: i32 = chunk_get_section_block(cs, chunk_x, chunk_z, section, lx, ly, lz);
                        if (bid != 0) { non_air = non_air + 1; }

                        // store in cache: index = (ly * 256 + lz * 16 + lx) * 2
                        let ci: i32 = cache_off + (ly * 256 + lz * 16 + lx) * 2;
                        wb[ci] = bid & 255;
                        wb[ci + 1] = (bid >> 8) & 255;

                        // add to palette if not already there
                        let found: bool = false;
                        let pi: i32 = 0;
                        while (pi < pal_count) {
                            let po: i32 = pal_off + pi * 2;
                            let pb0: i32 = wb[po];
                            let pb1: i32 = wb[po + 1];
                            if (pb0 < 0) { pb0 = pb0 + 256; }
                            if (pb1 < 0) { pb1 = pb1 + 256; }
                            let pal_val: i32 = pb0 | (pb1 << 8);
                            if (pal_val == bid) {
                                found = true;
                            }
                            pi = pi + 1;
                        }
                        if (!found && pal_count < 256) {
                            let po2: i32 = pal_off + pal_count * 2;
                            wb[po2] = bid & 255;
                            wb[po2 + 1] = (bid >> 8) & 255;
                            pal_count = pal_count + 1;
                        }
                        lz = lz + 1;
                    }
                    ly = ly + 1;
                }
                lx = lx + 1;
            }

            if (pal_count <= 1) {
                // uniform section - single-value palette
                let uniform_id: i32 = 0;
                if (pal_count == 1) {
                    let up0: i32 = wb[pal_off];
                    let up1: i32 = wb[pal_off + 1];
                    if (up0 < 0) { up0 = up0 + 256; }
                    if (up1 < 0) { up1 = up1 + 256; }
                    uniform_id = up0 | (up1 << 8);
                }

                // block count
                section_buf[pos] = (non_air >> 8) & 255;
                pos = pos + 1;
                section_buf[pos] = non_air & 255;
                pos = pos + 1;

                // bpe=0, palette=block_id
                section_buf[pos] = 0;
                pos = pos + 1;
                if (uniform_id < 128) {
                    section_buf[pos] = uniform_id;
                    pos = pos + 1;
                } else if (uniform_id < 16384) {
                    section_buf[pos] = (uniform_id & 127) | 128;
                    pos = pos + 1;
                    section_buf[pos] = (uniform_id >> 7) & 127;
                    pos = pos + 1;
                } else {
                    section_buf[pos] = (uniform_id & 127) | 128;
                    pos = pos + 1;
                    section_buf[pos] = ((uniform_id >> 7) & 127) | 128;
                    pos = pos + 1;
                    section_buf[pos] = (uniform_id >> 14) & 127;
                    pos = pos + 1;
                }

                // biomes
                section_buf[pos] = 0;
                pos = pos + 1;
                section_buf[pos] = 0;
                pos = pos + 1;
            } else {
                // mixed section - indirect palette
                let bpe: i32 = 4;
                if (pal_count > 16) { bpe = 5; }
                if (pal_count > 32) { bpe = 6; }
                if (pal_count > 64) { bpe = 7; }
                if (pal_count > 128) { bpe = 8; }

                // block count
                section_buf[pos] = (non_air >> 8) & 255;
                pos = pos + 1;
                section_buf[pos] = non_air & 255;
                pos = pos + 1;

                // bits per entry
                section_buf[pos] = bpe;
                pos = pos + 1;

                // palette length
                if (pal_count < 128) {
                    section_buf[pos] = pal_count;
                    pos = pos + 1;
                } else {
                    section_buf[pos] = (pal_count & 127) | 128;
                    pos = pos + 1;
                    section_buf[pos] = (pal_count >> 7) & 127;
                    pos = pos + 1;
                }

                // palette entries
                let pi2: i32 = 0;
                while (pi2 < pal_count) {
                    let po3: i32 = pal_off + pi2 * 2;
                    let ppb0: i32 = wb[po3];
                    let ppb1: i32 = wb[po3 + 1];
                    if (ppb0 < 0) { ppb0 = ppb0 + 256; }
                    if (ppb1 < 0) { ppb1 = ppb1 + 256; }
                    let pid: i32 = ppb0 | (ppb1 << 8);
                    if (pid < 128) {
                        section_buf[pos] = pid;
                        pos = pos + 1;
                    } else if (pid < 16384) {
                        section_buf[pos] = (pid & 127) | 128;
                        pos = pos + 1;
                        section_buf[pos] = (pid >> 7) & 127;
                        pos = pos + 1;
                    } else {
                        section_buf[pos] = (pid & 127) | 128;
                        pos = pos + 1;
                        section_buf[pos] = ((pid >> 7) & 127) | 128;
                        pos = pos + 1;
                        section_buf[pos] = (pid >> 14) & 127;
                        pos = pos + 1;
                    }
                    pi2 = pi2 + 1;
                }

                // data array - pack block palette indices into longs from cache
                let entries_per_long: i32 = 64 / bpe;
                let num_longs: i32 = (4096 + entries_per_long - 1) / entries_per_long;

                let entry_idx: i32 = 0;
                let long_idx: i32 = 0;
                while (long_idx < num_longs) {
                    let b0: i32 = 0;
                    let b1: i32 = 0;

                    let slot: i32 = 0;
                    while (slot < entries_per_long && entry_idx < 4096) {
                        // read block from cache instead of calling terrain gen again
                        let ey: i32 = entry_idx / 256;
                        let ez: i32 = (entry_idx / 16) % 16;
                        let ex: i32 = entry_idx % 16;
                        let ci2: i32 = cache_off + (ey * 256 + ez * 16 + ex) * 2;
                        let cv0: i32 = wb[ci2];
                        let cv1: i32 = wb[ci2 + 1];
                        if (cv0 < 0) { cv0 = cv0 + 256; }
                        if (cv1 < 0) { cv1 = cv1 + 256; }
                        let bid2: i32 = cv0 | (cv1 << 8);

                        // find palette index
                        let pal_idx: i32 = 0;
                        let pi3: i32 = 0;
                        while (pi3 < pal_count) {
                            let po4: i32 = pal_off + pi3 * 2;
                            let pv0: i32 = wb[po4];
                            let pv1: i32 = wb[po4 + 1];
                            if (pv0 < 0) { pv0 = pv0 + 256; }
                            if (pv1 < 0) { pv1 = pv1 + 256; }
                            let pval: i32 = pv0 | (pv1 << 8);
                            if (pval == bid2) {
                                pal_idx = pi3;
                            }
                            pi3 = pi3 + 1;
                        }

                        // pack into the long at bit position
                        let bit_pos: i32 = slot * bpe;
                        if (bit_pos < 32) {
                            if (bit_pos + bpe <= 32) {
                                b0 = b0 | (pal_idx << bit_pos);
                            } else {
                                b0 = b0 | (pal_idx << bit_pos);
                                b1 = b1 | (pal_idx >> (32 - bit_pos));
                            }
                        } else {
                            b1 = b1 | (pal_idx << (bit_pos - 32));
                        }

                        slot = slot + 1;
                        entry_idx = entry_idx + 1;
                    }

                    // write as big-endian i64
                    section_buf[pos] = (b1 >> 24) & 255;
                    section_buf[pos + 1] = (b1 >> 16) & 255;
                    section_buf[pos + 2] = (b1 >> 8) & 255;
                    section_buf[pos + 3] = b1 & 255;
                    section_buf[pos + 4] = (b0 >> 24) & 255;
                    section_buf[pos + 5] = (b0 >> 16) & 255;
                    section_buf[pos + 6] = (b0 >> 8) & 255;
                    section_buf[pos + 7] = b0 & 255;
                    pos = pos + 8;

                    long_idx = long_idx + 1;
                }

                // biomes
                section_buf[pos] = 0;
                pos = pos + 1;
                section_buf[pos] = 0;
                pos = pos + 1;
            }
        }

        section = section + 1;
    }

    let chunk_data_len: i32 = pos;

    // heightmaps = Prefixed Array of Heightmap structs
    // we send 0 (empty array) - client calculates its own
    let heightmap_vi: i32 = 1;  // VarInt(0)

    let data_size_vi: i32 = varint_size(chunk_data_len);
    let be_count_vi: i32 = 1;  // VarInt(0) for block entities

    // light data: 6x VarInt(0) for empty bitsets and arrays
    let light_data_size: i32 = 6;

    let payload_size: i32 = 4 + 4 + heightmap_vi + data_size_vi + chunk_data_len + be_count_vi + light_data_size;

    let pkt_id: i32 = 44;  // 0x2C Level Chunk With Light (protocol 774)
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload_size;

    // write the packet
    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);

    // chunk coordinates
    write_i32(fd, chunk_x);
    write_i32(fd, chunk_z);

    // heightmaps (empty prefixed array = VarInt 0)
    write_varint_to_fd(fd, 0);

    // chunk data
    write_varint_to_fd(fd, chunk_data_len);
    net_write(fd, section_buf, chunk_data_len);

    // block entities (0)
    write_varint_to_fd(fd, 0);

    // light data (all empty bitsets/arrays)
    write_varint_to_fd(fd, 0);  // sky light mask (empty bitset)
    write_varint_to_fd(fd, 0);  // block light mask
    write_varint_to_fd(fd, 0);  // empty sky light mask
    write_varint_to_fd(fd, 0);  // empty block light mask
    write_varint_to_fd(fd, 0);  // sky light arrays count
    write_varint_to_fd(fd, 0);  // block light arrays count
}

// ---------------------------------------------------------------------------
// chunk batch start/finished packets (0x0C / 0x0B in protocol 774)
// the MC client needs these to properly handle chunk loading timing
// ---------------------------------------------------------------------------

fn send_chunk_batch_start(fd: i32) -> void {
    let pkt_id: i32 = 12;  // 0x0C Chunk Batch Start (protocol 774)
    let id_len: i32 = varint_size(pkt_id);
    write_varint_to_fd(fd, id_len);
    write_varint_to_fd(fd, pkt_id);
}

fn send_chunk_batch_finished(fd: i32, batch_size: i32) -> void {
    let pkt_id: i32 = 11;  // 0x0B Chunk Batch Finished (protocol 774)
    let id_len: i32 = varint_size(pkt_id);
    let size_vi: i32 = varint_size(batch_size);
    write_varint_to_fd(fd, id_len + size_vi);
    write_varint_to_fd(fd, pkt_id);
    write_varint_to_fd(fd, batch_size);
}

// ---------------------------------------------------------------------------
// send chunks around spawn in a grid pattern
// for now we send a small area around 0,0
// ---------------------------------------------------------------------------

fn send_spawn_chunks(fd: i32, view_distance: i32, cs: str, wb: str) -> void {
    // send center chunk first
    send_center_chunk(fd, 0, 0);

    // send chunks in a square around spawn
    let radius: i32 = 3;  // 7x7 = 49 chunks
    if (view_distance < radius) {
        radius = view_distance;
    }

    // wrap chunks in a batch for proper client handling
    send_chunk_batch_start(fd);

    let chunk_count: i32 = 0;
    let cx: i32 = 0 - radius;
    while (cx <= radius) {
        let cz: i32 = 0 - radius;
        while (cz <= radius) {
            send_chunk_data(fd, cx, cz, cs, wb);
            chunk_count = chunk_count + 1;
            cz = cz + 1;
        }
        cx = cx + 1;
    }

    send_chunk_batch_finished(fd, chunk_count);
}

// ---------------------------------------------------------------------------
// send all the initial play state packets to get a player into the world
// returns the entity id assigned to the player
// ---------------------------------------------------------------------------

fn send_play_login(fd: i32, entity_id: i32, cs: str, wb: str) -> void {
    // 1. send login (play) packet
    send_login_play(fd, entity_id);

    // 2. game event: start waiting for level chunks (event 13)
    // value is the wait percentage as float bits... 0 means start
    send_game_event(fd, 13, 0);

    // 3. figure out spawn height from terrain generation
    let spawn_seed: i32 = cs_seed(cs);
    let spawn_y: i32 = terrain_height(0, 0, spawn_seed) + 1;

    // 3. set default spawn position
    send_spawn_position(fd, 0, spawn_y, 0);

    // 4. send chunks around spawn
    send_spawn_chunks(fd, 3, cs, wb);

    // 5. teleport player to spawn (on top of the terrain)
    send_player_position(fd, 0, spawn_y + 1, 0, 1);
}

// ---------------------------------------------------------------------------
// read and handle play state packets from the client
// returns false if the client disconnected
// ---------------------------------------------------------------------------

fn handle_play_packet(fd: i32, cs: str, world_seed: i32) -> bool {
    let ready: i32 = net_poll_read(fd, 100);
    if (ready < 0) { return false; }   // POLLHUP/POLLERR = disconnected
    if (ready == 0) { return true; }   // timeout, no data yet, still connected

    // poll says readable - but on macOS we need to verify theres actual data
    // cos poll can wake up with POLLIN + POLLHUP simultaneously on close
    // and net_read returns errno (positive) instead of -1 on error
    let avail: i32 = net_bytes_available(fd);
    if (avail <= 0) {
        // poll says readable but no bytes -> graceful close (EOF)
        return false;
    }

    let pkt_packed: i32 = read_varint_from_fd(fd);
    if (pkt_packed < 0) { return false; }

    let pkt_len: i32 = unpack_varint_value(pkt_packed);
    if (pkt_len <= 0) { return false; }

    // read the full packet
    let buf: str = net_make_buf(pkt_len + 1);
    let total_read: i32 = 0;
    while (total_read < pkt_len) {
        let remaining: i32 = pkt_len - total_read;
        let tmp: str = net_make_buf(remaining + 1);
        let nr: i32 = net_read(fd, tmp, remaining);
        if (nr <= 0) { return false; }
        let k: i32 = 0;
        while (k < nr) {
            buf[total_read + k] = tmp[k];
            k = k + 1;
        }
        total_read = total_read + nr;
    }

    // parse packet id
    let id_packed: i32 = read_varint_packed(buf, 0, pkt_len);
    let packet_id: i32 = unpack_varint_value(id_packed);

    // handle known play packets (serverbound IDs for 1.21.11 protocol 774)
    let id_size: i32 = unpack_varint_size(id_packed);

    if (packet_id == 0) {
        // 0x00 - Confirm Teleportation (accept_teleportation)
    } else if (packet_id == 8) {
        // 0x08 - Chat Message
    } else if (packet_id == 10) {
        // 0x0A - Chunk Batch Received
    } else if (packet_id == 27) {
        // 0x1B - Keep Alive (serverbound)
    } else if (packet_id == 29) {
        // 0x1D - Set Player Position (move_player_pos)
    } else if (packet_id == 30) {
        // 0x1E - Set Player Position and Rotation (move_player_pos_rot)
    } else if (packet_id == 31) {
        // 0x1F - Set Player Rotation (move_player_rot)
    } else if (packet_id == 32) {
        // 0x20 - Set Player Movement Flags (move_player_status_only)
    } else if (packet_id == 12) {
        // 0x0C - Client Tick End (client_tick_end)
    } else if (packet_id == 13) {
        // 0x0D - Client Information (client_information) play state
    } else if (packet_id == 40) {
        // 0x28 - Player Action (player_action)
        // this is block breaking, eating, shield etc
        // format: VarInt status, Position location, VarInt face, VarInt sequence
        handle_player_action(fd, buf, id_size, pkt_len, cs, world_seed);
    } else if (packet_id == 63) {
        // 0x3F - Use Item On (use_item_on)
        // block placement
        handle_use_item_on(fd, buf, id_size, pkt_len, cs, world_seed);
    }

    return true;
}

// ---------------------------------------------------------------------------
// send Block Update packet (0x08) to tell the client a block changed
// ---------------------------------------------------------------------------

fn send_block_update(fd: i32, x: i32, y: i32, z: i32, block_id: i32) -> void {
    // Block Update (0x08): Position + VarInt block_state_id
    let pkt_id: i32 = 8;  // 0x08 Block Update
    let id_len: i32 = varint_size(pkt_id);
    let block_vi: i32 = varint_size(block_id);
    let total: i32 = id_len + 8 + block_vi;  // 8 for packed position

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_position(fd, x, y, z);
    write_varint_to_fd(fd, block_id);
}

// ---------------------------------------------------------------------------
// send Block Changed Ack (0x04) - confirms we processed a block sequence
// ---------------------------------------------------------------------------

fn send_block_changed_ack(fd: i32, sequence: i32) -> void {
    let pkt_id: i32 = 4;  // 0x04 Block Changed Ack
    let id_len: i32 = varint_size(pkt_id);
    let seq_vi: i32 = varint_size(sequence);
    let total: i32 = id_len + seq_vi;

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_varint_to_fd(fd, sequence);
}

// ---------------------------------------------------------------------------
// decode a packed position (i64) from buffer into x, y, z
// returns packed: x in high bits, then z, then y
// position = ((x & 0x3FFFFFF) << 38) | ((z & 0x3FFFFFF) << 12) | (y & 0xFFF)
// ---------------------------------------------------------------------------

fn decode_position_x(buf: str, offset: i32) -> i32 {
    let b0: i32 = buf[offset];
    let b1: i32 = buf[offset + 1];
    let b2: i32 = buf[offset + 2];
    let b3: i32 = buf[offset + 3];
    if (b0 < 0) { b0 = b0 + 256; }
    if (b1 < 0) { b1 = b1 + 256; }
    if (b2 < 0) { b2 = b2 + 256; }
    if (b3 < 0) { b3 = b3 + 256; }
    // x is in bits 63-38 = top 26 bits of the i64
    // high word bits 31-6
    let high: i32 = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
    let x: i32 = high >> 6;
    // sign extend from 26 bits
    if (x >= 33554432) { x = x - 67108864; }
    return x;
}

fn decode_position_y(buf: str, offset: i32) -> i32 {
    let b6: i32 = buf[offset + 6];
    let b7: i32 = buf[offset + 7];
    if (b6 < 0) { b6 = b6 + 256; }
    if (b7 < 0) { b7 = b7 + 256; }
    // y is in bits 11-0 = bottom 12 bits of the i64
    let b5: i32 = buf[offset + 5];
    if (b5 < 0) { b5 = b5 + 256; }
    let y: i32 = ((b5 & 15) << 8) | (b6 << 0);
    // wait, lets recalculate. the low 32 bits are bytes 4-7
    let b4: i32 = buf[offset + 4];
    if (b4 < 0) { b4 = b4 + 256; }
    let low: i32 = (b4 << 24) | (b5 << 16) | (b6 << 8) | b7;
    y = low & 4095;
    // sign extend from 12 bits
    if (y >= 2048) { y = y - 4096; }
    return y;
}

fn decode_position_z(buf: str, offset: i32) -> i32 {
    let b0: i32 = buf[offset];
    let b1: i32 = buf[offset + 1];
    let b2: i32 = buf[offset + 2];
    let b3: i32 = buf[offset + 3];
    let b4: i32 = buf[offset + 4];
    let b5: i32 = buf[offset + 5];
    let b6: i32 = buf[offset + 6];
    let b7: i32 = buf[offset + 7];
    if (b0 < 0) { b0 = b0 + 256; }
    if (b1 < 0) { b1 = b1 + 256; }
    if (b2 < 0) { b2 = b2 + 256; }
    if (b3 < 0) { b3 = b3 + 256; }
    if (b4 < 0) { b4 = b4 + 256; }
    if (b5 < 0) { b5 = b5 + 256; }
    if (b6 < 0) { b6 = b6 + 256; }
    if (b7 < 0) { b7 = b7 + 256; }
    // z is in bits 37-12 = 26 bits
    // low word bits 31-12 = z bits 19-0
    let low: i32 = (b4 << 24) | (b5 << 16) | (b6 << 8) | b7;
    let z_low: i32 = (low >> 12) & 1048575;  // 20 bits
    // high word bits 5-0 = z bits 25-20
    let high: i32 = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
    let z_high: i32 = high & 63;  // 6 bits
    let z: i32 = (z_high << 20) | z_low;
    // sign extend from 26 bits
    if (z >= 33554432) { z = z - 67108864; }
    return z;
}

// ---------------------------------------------------------------------------
// handle Player Action packet (0x28 / id 40)
// status 0 = started digging, 1 = cancelled, 2 = finished digging
// for creative mode, status 0 = instant break
// ---------------------------------------------------------------------------

fn handle_player_action(fd: i32, buf: str, id_size: i32, pkt_len: i32, cs: str, world_seed: i32) -> void {
    let pos: i32 = id_size;

    // read status (VarInt)
    let status_packed: i32 = read_varint_packed(buf, pos, pkt_len);
    let status: i32 = unpack_varint_value(status_packed);
    let status_size: i32 = unpack_varint_size(status_packed);
    pos = pos + status_size;

    // read position (8 bytes packed i64)
    if (pos + 8 > pkt_len) { return; }
    let bx: i32 = decode_position_x(buf, pos);
    let by: i32 = decode_position_y(buf, pos);
    let bz: i32 = decode_position_z(buf, pos);
    pos = pos + 8;

    // read face (VarInt)
    let face_packed: i32 = read_varint_packed(buf, pos, pkt_len);
    let face: i32 = unpack_varint_value(face_packed);
    let face_size: i32 = unpack_varint_size(face_packed);
    pos = pos + face_size;

    // read sequence (VarInt)
    let seq_packed: i32 = read_varint_packed(buf, pos, pkt_len);
    let sequence: i32 = unpack_varint_value(seq_packed);

    if (status == 0) {
        let old_block: i32 = chunk_get_block_seed(cs, bx, by, bz, world_seed);
        log_debug("creative break check");
        if (old_block != 0) {
            chunk_set_block(cs, bx, by, bz, 0);
            send_block_update(fd, bx, by, bz, 0);
            log_debug("block broken (creative)");
        } else {
            log_debug("block was air - nothing to break");
        }
        send_block_changed_ack(fd, sequence);
    } else if (status == 2) {
        let old_block2: i32 = chunk_get_block_seed(cs, bx, by, bz, world_seed);
        if (old_block2 != 0) {
            chunk_set_block(cs, bx, by, bz, 0);
            send_block_update(fd, bx, by, bz, 0);
            log_debug("block broken (survival)");
        }
        send_block_changed_ack(fd, sequence);
    } else if (status == 1) {
        send_block_changed_ack(fd, sequence);
    }
}

// ---------------------------------------------------------------------------
// handle Use Item On packet (0x3F / id 63)
// this is block placement
// format: VarInt hand, Position location, VarInt face,
//         float cursor_x, float cursor_y, float cursor_z,
//         bool inside_block, bool world_border_hit, VarInt sequence
// ---------------------------------------------------------------------------

fn handle_use_item_on(fd: i32, buf: str, id_size: i32, pkt_len: i32, cs: str, world_seed: i32) -> void {
    let pos: i32 = id_size;

    // read hand (VarInt)
    let hand_packed: i32 = read_varint_packed(buf, pos, pkt_len);
    let hand: i32 = unpack_varint_value(hand_packed);
    let hand_size: i32 = unpack_varint_size(hand_packed);
    pos = pos + hand_size;

    // read position (8 bytes packed i64) - the block we clicked ON
    if (pos + 8 > pkt_len) { return; }
    let bx: i32 = decode_position_x(buf, pos);
    let by: i32 = decode_position_y(buf, pos);
    let bz: i32 = decode_position_z(buf, pos);
    pos = pos + 8;

    // read face (VarInt) - which face of the block was clicked
    // 0=bottom, 1=top, 2=north, 3=south, 4=west, 5=east
    let face_packed: i32 = read_varint_packed(buf, pos, pkt_len);
    let face: i32 = unpack_varint_value(face_packed);
    let face_size: i32 = unpack_varint_size(face_packed);
    pos = pos + face_size;

    // skip cursor_x, cursor_y, cursor_z (3 floats = 12 bytes)
    pos = pos + 12;

    // skip inside_block (1 byte) and world_border_hit (1 byte)
    pos = pos + 2;

    // read sequence (VarInt)
    if (pos >= pkt_len) { return; }
    let seq_packed: i32 = read_varint_packed(buf, pos, pkt_len);
    let sequence: i32 = unpack_varint_value(seq_packed);

    // calculate the position where the new block goes
    // its adjacent to the clicked block on the clicked face
    let nx: i32 = bx;
    let ny: i32 = by;
    let nz: i32 = bz;
    if (face == 0) { ny = by - 1; }       // bottom
    else if (face == 1) { ny = by + 1; }   // top
    else if (face == 2) { nz = bz - 1; }   // north
    else if (face == 3) { nz = bz + 1; }   // south
    else if (face == 4) { nx = bx - 1; }   // west
    else if (face == 5) { nx = bx + 1; }   // east

    // place a stone block (id 1) for now - proper inventory system later
    // only place if the target position is currently air
    let current: i32 = chunk_get_block(cs, nx, ny, nz);
    if (current == 0) {
        chunk_set_block(cs, nx, ny, nz, 1);
        send_block_update(fd, nx, ny, nz, 1);
        log_debug("block placed");
    }
    send_block_changed_ack(fd, sequence);
}

// ---------------------------------------------------------------------------
// send keep alive packet to prevent timeout
// Keep Alive (0x2B): i64 keep alive id
// ---------------------------------------------------------------------------

fn send_keep_alive(fd: i32, keep_alive_id: i32) -> void {
    let payload: i32 = 8;  // i64
    let pkt_id: i32 = 43;  // 0x2B Keep Alive (play)
    let id_len: i32 = varint_size(pkt_id);
    let total: i32 = id_len + payload;

    write_varint_to_fd(fd, total);
    write_varint_to_fd(fd, pkt_id);
    write_i64_parts(fd, 0, keep_alive_id);
}
