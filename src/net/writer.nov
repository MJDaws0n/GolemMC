// ---------------------------------------------------------------------------
// writer.nov - binary data writing helpers for MC protocol
//
// minecraft protocol needs loads of different data types written in
// specific formats (big-endian, varints, etc). this module handles
// writing all of em directly to a socket fd so we dont have to deal
// with null byte issues in novus strings
//
// all the write functions take a fd and write directly to it
// ---------------------------------------------------------------------------

module writer;

import ../../lib/standard_lib;
import ../../lib/standard_lib_macos_silicon;
import ../../lib/net;
import ../../lib/memory;
import packet;

// ---------------------------------------------------------------------------
// single byte write
// ---------------------------------------------------------------------------

fn write_byte(fd: i32, val: i32) -> void {
    let b: str = "\0";
    b[0] = val % 256;
    net_write(fd, b, 1);
}

// ---------------------------------------------------------------------------
// boolean - just a byte, 0 or 1
// ---------------------------------------------------------------------------

fn write_bool(fd: i32, val: bool) -> void {
    if (val) {
        write_byte(fd, 1);
    } else {
        write_byte(fd, 0);
    }
}

// ---------------------------------------------------------------------------
// unsigned byte (same as write_byte but clearer intent)
// ---------------------------------------------------------------------------

fn write_ubyte(fd: i32, val: i32) -> void {
    write_byte(fd, val);
}

// ---------------------------------------------------------------------------
// i16 big-endian (2 bytes)
// ---------------------------------------------------------------------------

fn write_i16(fd: i32, val: i32) -> void {
    let v: i32 = val;
    if (v < 0) { v = v + 65536; }
    write_byte(fd, (v >> 8) & 255);
    write_byte(fd, v & 255);
}

// ---------------------------------------------------------------------------
// i32 big-endian (4 bytes)
// ---------------------------------------------------------------------------

fn write_i32(fd: i32, val: i32) -> void {
    write_byte(fd, (val >> 24) & 255);
    write_byte(fd, (val >> 16) & 255);
    write_byte(fd, (val >> 8) & 255);
    write_byte(fd, val & 255);
}

// ---------------------------------------------------------------------------
// i64 big-endian (8 bytes) - takes two i32s (high, low) since novus
// i64 support is limited for bit manipulation
// ---------------------------------------------------------------------------

fn write_i64_parts(fd: i32, high: i32, low: i32) -> void {
    write_i32(fd, high);
    write_i32(fd, low);
}

// write a zero i64
fn write_i64_zero(fd: i32) -> void {
    write_i64_parts(fd, 0, 0);
}

// ---------------------------------------------------------------------------
// float (4 bytes big-endian IEEE 754)
// for now we only need specific float values so we hardcode the bytes
// ---------------------------------------------------------------------------

// write 0.0f = 0x00000000
fn write_float_zero(fd: i32) -> void {
    write_i32(fd, 0);
}

// write 1.0f = 0x3F800000
fn write_float_one(fd: i32) -> void {
    write_i32(fd, 1065353216);
}

// write 20.0f = 0x41A00000 (for health)
fn write_float_twenty(fd: i32) -> void {
    write_i32(fd, 1101004800);
}

// ---------------------------------------------------------------------------
// double (8 bytes big-endian IEEE 754)
// again, hardcode specific values we need
// ---------------------------------------------------------------------------

// write 0.0 double
fn write_double_zero(fd: i32) -> void {
    write_i64_zero(fd);
}

// write a double from integer value (approximate - good enough for coords)
// converts an integer to IEEE 754 double representation
fn write_double_from_i32(fd: i32, val: i32) -> void {
    if (val == 0) {
        write_i64_zero(fd);
        return;
    }

    let sign: i32 = 0;
    let v: i32 = val;
    if (v < 0) {
        sign = 1;
        v = 0 - v;
    }

    // find highest bit position (exponent)
    let exp: i32 = 0;
    let tmp: i32 = v;
    while (tmp > 1) {
        tmp = tmp >> 1;
        exp = exp + 1;
    }

    // biased exponent = exp + 1023
    let biased: i32 = exp + 1023;

    // remove the implicit leading 1 bit
    let leading: i32 = 1 << exp;
    let mantissa_val: i32 = v - leading;

    // high 32 bits: sign(1) + exponent(11) + mantissa_high(20)
    let h: i32 = (sign << 31) | (biased << 20);

    if (exp <= 20) {
        // all mantissa fits in high word
        h = h | (mantissa_val << (20 - exp));
        write_i32(fd, h);
        write_i32(fd, 0);
    } else {
        // mantissa spans both words
        let high_bits: i32 = mantissa_val >> (exp - 20);
        h = h | high_bits;

        // low word: remaining bits shifted left
        let low_bits: i32 = mantissa_val - (high_bits << (exp - 20));
        low_bits = low_bits << (32 - (exp - 20));
        write_i32(fd, h);
        write_i32(fd, low_bits);
    }
}

// ---------------------------------------------------------------------------
// MC string - VarInt length + UTF-8 bytes
// ---------------------------------------------------------------------------

fn write_mc_string(fd: i32, s: str) -> void {
    write_varint_to_fd(fd, len(s));
    if (len(s) > 0) {
        net_write(fd, s, len(s));
    }
}

// ---------------------------------------------------------------------------
// MC identifier string (namespace:path format)
// ---------------------------------------------------------------------------

fn write_identifier(fd: i32, s: str) -> void {
    write_mc_string(fd, s);
}

// ---------------------------------------------------------------------------
// position (packed i64) - x(26 bits) | z(26 bits) | y(12 bits)
// x and z are signed 26-bit, y is signed 12-bit
// packed as: ((x & 0x3FFFFFF) << 38) | ((z & 0x3FFFFFF) << 12) | (y & 0xFFF)
// ---------------------------------------------------------------------------

fn write_position(fd: i32, x: i32, y: i32, z: i32) -> void {
    // packed i64: x(26 bits) << 38 | z(26 bits) << 12 | y(12 bits)
    // we build 8 bytes big-endian using bitwise ops now frfr

    let xv: i32 = x & 67108863;   // x & 0x3FFFFFF (26 bits)
    let zv: i32 = z & 67108863;   // z & 0x3FFFFFF
    let yv: i32 = y & 4095;       // y & 0xFFF (12 bits)

    let b: str = "\0\0\0\0\0\0\0\0";

    // byte 0-3: high 32 bits = (xv << 6) | (zv >> 20)
    // because x occupies bits 63-38 in the i64 = bits 31-6 in high word
    // and z bits 25-20 go into bits 5-0 of high word
    let high: i32 = (xv << 6) | (zv >> 20);
    b[0] = (high >> 24) & 255;
    b[1] = (high >> 16) & 255;
    b[2] = (high >> 8) & 255;
    b[3] = high & 255;

    // byte 4-7: low 32 bits = (zv << 12) | yv
    // z bits 19-0 shifted left by 12, plus y bits
    let low: i32 = (zv << 12) | yv;
    b[4] = (low >> 24) & 255;
    b[5] = (low >> 16) & 255;
    b[6] = (low >> 8) & 255;
    b[7] = low & 255;

    net_write(fd, b, 8);
}

// ---------------------------------------------------------------------------
// UUID - 16 bytes, two i64s basically
// for offline mode we just hash the username
// ---------------------------------------------------------------------------

fn write_uuid_offline(fd: i32, username: str) -> void {
    // generate a deterministic UUID from the username
    // use a simple hash - doesnt need to be real MD5
    let h1: i32 = 0;
    let h2: i32 = 0;
    let h3: i32 = 0;
    let h4: i32 = 0;
    let i: i32 = 0;
    while (i < len(username)) {
        let c: i32 = username[i];
        if (c < 0) { c = c + 256; }
        h1 = (h1 * 31 + c) % 2147483647;
        h2 = (h2 * 37 + c + 7) % 2147483647;
        h3 = (h3 * 41 + c + 13) % 2147483647;
        h4 = (h4 * 43 + c + 19) % 2147483647;
        i = i + 1;
    }
    // make it look like a version 3 UUID
    // set version bits (bits 12-15 of byte 6 = 0011)
    write_i32(fd, h1);
    write_i32(fd, h2);
    write_i32(fd, h3);
    write_i32(fd, h4);
}

// get uuid as hex string (for logging and stuff)
fn uuid_hex_from_name(username: str) -> str {
    let h1: i32 = 0;
    let h2: i32 = 0;
    let h3: i32 = 0;
    let h4: i32 = 0;
    let i: i32 = 0;
    while (i < len(username)) {
        let c: i32 = username[i];
        if (c < 0) { c = c + 256; }
        h1 = (h1 * 31 + c) % 2147483647;
        h2 = (h2 * 37 + c + 7) % 2147483647;
        h3 = (h3 * 41 + c + 13) % 2147483647;
        h4 = (h4 * 43 + c + 19) % 2147483647;
        i = i + 1;
    }
    return i32_to_str(h1) + "-" + i32_to_str(h2) + "-" + i32_to_str(h3) + "-" + i32_to_str(h4);
}

// ---------------------------------------------------------------------------
// NBT writing helpers - needed for chunk data and registry entries
// MC uses NBT (Named Binary Tag) format for structured data
// ---------------------------------------------------------------------------

// NBT tag types
fn nbt_end() -> i32 { return 0; }
fn nbt_byte() -> i32 { return 1; }
fn nbt_short() -> i32 { return 2; }
fn nbt_int() -> i32 { return 3; }
fn nbt_long() -> i32 { return 4; }
fn nbt_float() -> i32 { return 5; }
fn nbt_double() -> i32 { return 6; }
fn nbt_string() -> i32 { return 8; }
fn nbt_list() -> i32 { return 9; }
fn nbt_compound() -> i32 { return 10; }
fn nbt_int_array() -> i32 { return 11; }
fn nbt_long_array() -> i32 { return 12; }

// write an NBT tag header (type + name)
fn write_nbt_header(fd: i32, tag_type: i32, name: str) -> void {
    write_byte(fd, tag_type);
    // NBT strings use u16 length prefix (not VarInt)
    write_i16(fd, len(name));
    if (len(name) > 0) {
        net_write(fd, name, len(name));
    }
}

// write NBT compound start with name
fn write_nbt_compound(fd: i32, name: str) -> void {
    write_nbt_header(fd, 10, name);
}

// write NBT compound end
fn write_nbt_end(fd: i32) -> void {
    write_byte(fd, 0);
}

// write NBT string value (with tag header)
fn write_nbt_string(fd: i32, name: str, value: str) -> void {
    write_nbt_header(fd, 8, name);
    write_i16(fd, len(value));
    if (len(value) > 0) {
        net_write(fd, value, len(value));
    }
}

// write NBT int value (with tag header)
fn write_nbt_int(fd: i32, name: str, value: i32) -> void {
    write_nbt_header(fd, 3, name);
    write_i32(fd, value);
}

// write NBT byte value (with tag header)
fn write_nbt_byte(fd: i32, name: str, value: i32) -> void {
    write_nbt_header(fd, 1, name);
    write_byte(fd, value);
}

// write NBT float value (with tag header) - only supports specific values rn
fn write_nbt_float(fd: i32, name: str, value: i32) -> void {
    write_nbt_header(fd, 5, name);
    write_i32(fd, value);  // caller passes raw IEEE 754 bits
}

// write NBT long value as two i32s
fn write_nbt_long(fd: i32, name: str, high: i32, low: i32) -> void {
    write_nbt_header(fd, 4, name);
    write_i32(fd, high);
    write_i32(fd, low);
}

// write an NBT list header
fn write_nbt_list(fd: i32, name: str, element_type: i32, count: i32) -> void {
    write_nbt_header(fd, 9, name);
    write_byte(fd, element_type);
    write_i32(fd, count);
}

// write a raw NBT string value (no tag header, just length + data)
fn write_nbt_string_raw(fd: i32, value: str) -> void {
    write_i16(fd, len(value));
    if (len(value) > 0) {
        net_write(fd, value, len(value));
    }
}

// ---------------------------------------------------------------------------
// helper to read a MC string from buffer (VarInt length + UTF-8)
// ---------------------------------------------------------------------------

fn read_mc_string(buf: str, pos: i32, max_pos: i32) -> str {
    let len_packed: i32 = read_varint_packed(buf, pos, max_pos);
    let str_len: i32 = unpack_varint_value(len_packed);
    let len_size: i32 = unpack_varint_size(len_packed);
    let start: i32 = pos + len_size;

    let result: str = "";
    let i: i32 = 0;
    while (i < str_len && start + i < max_pos) {
        result = result + buf[start + i];
        i = i + 1;
    }
    return result;
}

// get total bytes consumed by an MC string in a buffer
fn mc_string_total_size(buf: str, pos: i32, max_pos: i32) -> i32 {
    let len_packed: i32 = read_varint_packed(buf, pos, max_pos);
    let str_len: i32 = unpack_varint_value(len_packed);
    let len_size: i32 = unpack_varint_size(len_packed);
    return len_size + str_len;
}
